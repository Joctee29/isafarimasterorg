const express = require('express');
const router = express.Router();
const passport = require('passport');
const { User, ServiceProvider, Service, Booking, Payment, Review } = require('../models');
const { serializeDocument, serializeDocuments } = require('../utils/mongodb-helpers');

// Middleware to bypass authentication for admin portal (temporary - for development)
const authenticateJWT = (req, res, next) => {
  // Skip authentication for now - admin portal has direct access
  next();
};

// Middleware to check if user is admin
const isAdmin = (req, res, next) => {
  // For now, allow all requests to admin endpoints
  // In production, add proper admin role checking
  next();
};

// ==========================================
// DASHBOARD & ANALYTICS
// ==========================================

// Get dashboard analytics
router.get('/analytics/dashboard', authenticateJWT, isAdmin, async (req, res) => {
  try {
    console.log('ðŸ“Š Fetching dashboard analytics...');

    const { period = '30' } = req.query;
    const daysAgo = parseInt(period);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - daysAgo);

    // Get basic stats with error handling
    let basicStats = {};
    try {
      const [
        totalUsers,
        totalServices,
        totalBookings,
        activeServices,
        pendingServices,
        totalTravelers,
        totalProviders,
        newUsersToday,
        completedToday
      ] = await Promise.all([
        User.countDocuments().catch(() => 0),
        Service.countDocuments().catch(() => 0),
        Booking.countDocuments().catch(() => 0),
        Service.countDocuments({ is_active: true }).catch(() => 0),
        Service.countDocuments({ is_active: false }).catch(() => 0),
        User.countDocuments({ user_type: 'traveler' }).catch(() => 0),
        User.countDocuments({ user_type: 'service_provider' }).catch(() => 0),
        User.countDocuments({ created_at: { $gte: new Date().setHours(0, 0, 0, 0) } }).catch(() => 0),
        Booking.countDocuments({ status: 'completed', updated_at: { $gte: new Date().setHours(0, 0, 0, 0) } }).catch(() => 0)
      ]);

      basicStats = {
        totalUsers,
        totalServices,
        totalBookings,
        activeServices,
        pendingServices,
        totalTravelers,
        totalProviders,
        newUsersToday,
        completedToday,
        openTickets: 0
      };

      console.log('âœ… Basic stats fetched:', basicStats);
    } catch (error) {
      console.error('âŒ Error fetching basic stats:', error.message);
      basicStats = {
        totalUsers: 0,
        totalServices: 0,
        totalBookings: 0,
        activeServices: 0,
        pendingServices: 0,
        totalTravelers: 0,
        totalProviders: 0,
        newUsersToday: 0,
        completedToday: 0,
        openTickets: 0
      };
    }

    // Get revenue data with error handling
    let revenueData = [];
    let monthlyRevenue = 0;
    try {
      revenueData = await Payment.aggregate([
        { $match: { payment_status: 'completed', created_at: { $gte: startDate } } },
        {
          $group: {
            _id: { $dateToString: { format: '%Y-%m-%d', date: '$created_at' } },
            total: { $sum: '$amount' }
          }
        },
        { $sort: { _id: 1 } }
      ]).catch(() => []);

      const monthStart = new Date();
      monthStart.setDate(1);
      monthStart.setHours(0, 0, 0, 0);

      const monthlyRevenueResult = await Payment.aggregate([
        { $match: { payment_status: 'completed', created_at: { $gte: monthStart } } },
        { $group: { _id: null, total: { $sum: '$amount' } } }
      ]).catch(() => []);

      monthlyRevenue = monthlyRevenueResult[0]?.total || 0;
      console.log('âœ… Revenue data fetched');
    } catch (error) {
      console.error('âŒ Error fetching revenue data:', error.message);
    }

    // Get bookings by status with error handling
    let bookingsData = [];
    try {
      bookingsData = await Booking.aggregate([
        {
          $group: {
            _id: '$status',
            count: { $sum: 1 }
          }
        }
      ]).catch(() => []);
      console.log('âœ… Bookings data fetched');
    } catch (error) {
      console.error('âŒ Error fetching bookings data:', error.message);
    }

    // Get users growth data with error handling
    let usersData = [];
    try {
      usersData = await User.aggregate([
        { $match: { created_at: { $gte: startDate } } },
        {
          $group: {
            _id: { $dateToString: { format: '%Y-%m-%d', date: '$created_at' } },
            count: { $sum: 1 }
          }
        },
        { $sort: { _id: 1 } }
      ]).catch(() => []);
      console.log('âœ… Users growth data fetched');
    } catch (error) {
      console.error('âŒ Error fetching users growth data:', error.message);
    }

    // Get services by category with error handling
    let servicesData = [];
    try {
      servicesData = await Service.aggregate([
        {
          $group: {
            _id: '$category',
            count: { $sum: 1 }
          }
        }
      ]).catch(() => []);
      console.log('âœ… Services by category fetched');
    } catch (error) {
      console.error('âŒ Error fetching services by category:', error.message);
    }

    // Get recent activity with error handling
    let recentActivity = [];
    try {
      const recentUsers = await User.find().sort({ created_at: -1 }).limit(5).lean().catch(() => []);
      const recentServices = await Service.find().sort({ created_at: -1 }).limit(5).lean().catch(() => []);
      const recentBookings = await Booking.find().sort({ created_at: -1 }).limit(5).lean().catch(() => []);

      recentActivity = [
        ...recentUsers.map(u => ({
          id: u._id,
          action: 'user_created',
          description: `New user registered: ${u.name || 'Unknown'}`,
          user: { name: u.name || 'Unknown' },
          createdAt: u.created_at
        })),
        ...recentServices.map(s => ({
          id: s._id,
          action: 'service_created',
          description: `New service added: ${s.title || 'Unknown'}`,
          user: { name: 'Service Provider' },
          createdAt: s.created_at
        })),
        ...recentBookings.map(b => ({
          id: b._id,
          action: 'booking_created',
          description: `New booking created`,
          user: { name: 'Traveler' },
          createdAt: b.created_at
        }))
      ].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)).slice(0, 10);

      console.log('âœ… Recent activity fetched');
    } catch (error) {
      console.error('âŒ Error fetching recent activity:', error.message);
    }

    // Get top services with error handling
    let topServices = [];
    try {
      const topServicesData = await Booking.aggregate([
        {
          $group: {
            _id: '$service_id',
            bookings: { $sum: 1 },
            revenue: { $sum: '$total_amount' }
          }
        },
        { $sort: { bookings: -1 } },
        { $limit: 5 },
        {
          $lookup: {
            from: 'services',
            localField: '_id',
            foreignField: '_id',
            as: 'service'
          }
        },
        { $unwind: { path: '$service', preserveNullAndEmptyArrays: true } }
      ]).catch(() => []);

      topServices = topServicesData
        .filter(s => s.service)
        .map(s => ({
          id: s.service._id,
          title: s.service.title || 'Unknown',
          bookings: s.bookings,
          revenue: s.revenue || 0,
          rating: s.service.average_rating || 0
        }));

      console.log('âœ… Top services fetched');
    } catch (error) {
      console.error('âŒ Error fetching top services:', error.message);
    }

    // Get top providers with error handling
    let topProviders = [];
    try {
      const topProvidersData = await Service.aggregate([
        {
          $lookup: {
            from: 'bookings',
            localField: '_id',
            foreignField: 'service_id',
            as: 'bookings'
          }
        },
        {
          $group: {
            _id: '$provider_id',
            services: { $sum: 1 },
            bookings: { $sum: { $size: '$bookings' } }
          }
        },
        { $sort: { bookings: -1 } },
        { $limit: 5 },
        {
          $lookup: {
            from: 'serviceproviders',
            localField: '_id',
            foreignField: '_id',
            as: 'provider'
          }
        },
        { $unwind: { path: '$provider', preserveNullAndEmptyArrays: true } },
        {
          $lookup: {
            from: 'users',
            localField: 'provider.user_id',
            foreignField: '_id',
            as: 'user'
          }
        },
        { $unwind: { path: '$user', preserveNullAndEmptyArrays: true } }
      ]).catch(() => []);

      topProviders = topProvidersData
        .filter(p => p.user)
        .map(p => ({
          id: p.user._id,
          name: p.user.name || 'Unknown',
          avatar: p.user.profile_picture,
          services: p.services,
          bookings: p.bookings,
          revenue: 0
        }));

      console.log('âœ… Top providers fetched');
    } catch (error) {
      console.error('âŒ Error fetching top providers:', error.message);
    }

    // Get user verifications count
    let userVerifications = 0;
    try {
      userVerifications = await User.countDocuments({ is_verified: false }).catch(() => 0);
    } catch (error) {
      console.error('âŒ Error fetching user verifications:', error.message);
    }

    // Get active sessions count
    let activeSessions = 0;
    try {
      activeSessions = await User.countDocuments({ is_active: true }).catch(() => 0);
    } catch (error) {
      console.error('âŒ Error fetching active sessions:', error.message);
    }

    console.log('âœ… Dashboard analytics completed successfully');

    res.json({
      success: true,
      stats: {
        totalUsers: basicStats.totalUsers,
        activeServices: basicStats.activeServices,
        totalBookings: basicStats.totalBookings,
        monthlyRevenue: monthlyRevenue,
        pendingApprovals: basicStats.pendingServices,
        newUsersToday: basicStats.newUsersToday,
        completedToday: basicStats.completedToday,
        openTickets: 0,
        totalTravelers: basicStats.totalTravelers,
        totalProviders: basicStats.totalProviders
      },
      revenueData: {
        labels: revenueData.map(d => d._id),
        values: revenueData.map(d => d.total)
      },
      bookingsData: {
        labels: bookingsData.map(d => d._id),
        values: bookingsData.map(d => d.count)
      },
      usersData: {
        labels: usersData.map(d => d._id),
        values: usersData.map(d => d.count)
      },
      servicesData: {
        labels: servicesData.map(d => d._id || 'Uncategorized'),
        values: servicesData.map(d => d.count)
      },
      recentActivity,
      pendingActions: {
        userVerifications,
        serviceApprovals: basicStats.pendingServices,
        supportTickets: 0,
        pendingPayouts: 0
      },
      topServices,
      topProviders,
      systemHealth: {
        apiResponseTime: '45ms',
        databaseStatus: 'Connected',
        serverUptime: '99.9%',
        activeSessions
      }
    });
  } catch (error) {
    console.error('âŒ CRITICAL Error fetching dashboard analytics:', error);
    console.error('Stack trace:', error.stack);
    res.status(500).json({
      success: false,
      message: 'Error fetching dashboard analytics',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Get dashboard statistics (legacy endpoint)
router.get('/dashboard-stats', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const [
      totalUsers,
      totalServices,
      totalBookings,
      totalRevenue,
      activeServices,
      pendingBookings
    ] = await Promise.all([
      User.countDocuments(),
      Service.countDocuments(),
      Booking.countDocuments(),
      Payment.aggregate([
        { $match: { payment_status: 'completed' } },
        { $group: { _id: null, total: { $sum: '$amount' } } }
      ]),
      Service.countDocuments({ is_active: true }),
      Booking.countDocuments({ status: 'pending' })
    ]);

    res.json({
      success: true,
      stats: {
        totalUsers,
        totalServices,
        totalBookings,
        totalRevenue: totalRevenue[0]?.total || 0,
        activeServices,
        pendingBookings,
        totalTravelers: await User.countDocuments({ user_type: 'traveler' }),
        totalProviders: await User.countDocuments({ user_type: 'service_provider' })
      }
    });
  } catch (error) {
    console.error('Error fetching dashboard stats:', error);
    res.status(500).json({ success: false, message: 'Error fetching dashboard statistics' });
  }
});

// ==========================================
// USER MANAGEMENT
// ==========================================

// Get all users with filters
router.get('/users', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { role, status, search, page = 1, limit = 20 } = req.query;
    const filter = {};

    if (role) filter.user_type = role;
    if (status === 'active') filter.is_active = true;
    if (status === 'suspended') filter.is_active = false;
    if (search) {
      filter.$or = [
        { name: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } }
      ];
    }

    const users = await User.find(filter)
      .skip((page - 1) * limit)
      .limit(parseInt(limit))
      .sort({ created_at: -1 })
      .lean();

    const total = await User.countDocuments(filter);

    // Get stats
    const stats = {
      total: await User.countDocuments(),
      travelers: await User.countDocuments({ user_type: 'traveler' }),
      providers: await User.countDocuments({ user_type: 'service_provider' }),
      activeToday: await User.countDocuments({
        last_login: { $gte: new Date().setHours(0, 0, 0, 0) }
      })
    };

    res.json({
      success: true,
      users: serializeDocuments(users),
      stats,
      total,
      page: parseInt(page),
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ success: false, message: 'Error fetching users' });
  }
});

// Get user by ID
router.get('/users/:userId', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;
    const user = await User.findById(userId).lean();

    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    // Get additional stats for the user
    let stats = {};
    if (user.user_type === 'service_provider') {
      const provider = await ServiceProvider.findOne({ user_id: userId });
      if (provider) {
        stats = {
          totalServices: await Service.countDocuments({ provider_id: provider._id }),
          totalBookings: await Booking.countDocuments({
            service_id: { $in: await Service.find({ provider_id: provider._id }).distinct('_id') }
          }),
          totalRevenue: 0 // Calculate from payments if needed
        };
      }
    }

    res.json({
      success: true,
      user: { ...serializeDocument(user), stats }
    });
  } catch (error) {
    console.error('Error fetching user:', error);
    res.status(500).json({ success: false, message: 'Error fetching user' });
  }
});

// Get user stats
router.get('/users/stats', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const stats = {
      total: await User.countDocuments(),
      travelers: await User.countDocuments({ user_type: 'traveler' }),
      providers: await User.countDocuments({ user_type: 'service_provider' }),
      active: await User.countDocuments({ is_active: true }),
      verified: await User.countDocuments({ is_verified: true })
    };

    res.json({ success: true, stats });
  } catch (error) {
    console.error('Error fetching user stats:', error);
    res.status(500).json({ success: false, message: 'Error fetching user stats' });
  }
});

// Update user status
router.put('/users/:userId/status', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;
    const { isActive } = req.body;

    const user = await User.findByIdAndUpdate(
      userId,
      { is_active: isActive },
      { new: true }
    ).lean();

    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    res.json({
      success: true,
      message: `User ${isActive ? 'activated' : 'deactivated'} successfully`,
      user: serializeDocument(user)
    });
  } catch (error) {
    console.error('Error updating user status:', error);
    res.status(500).json({ success: false, message: 'Error updating user status' });
  }
});

// Verify user
router.post('/users/:userId/verify', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;

    const user = await User.findByIdAndUpdate(
      userId,
      { is_verified: true },
      { new: true }
    ).lean();

    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    res.json({
      success: true,
      message: 'User verified successfully',
      user: serializeDocument(user)
    });
  } catch (error) {
    console.error('Error verifying user:', error);
    res.status(500).json({ success: false, message: 'Error verifying user' });
  }
});

// Suspend user
router.post('/users/:userId/suspend', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;
    const { reason } = req.body;

    const user = await User.findByIdAndUpdate(
      userId,
      { is_active: false, suspension_reason: reason },
      { new: true }
    ).lean();

    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    res.json({
      success: true,
      message: 'User suspended successfully',
      user: serializeDocument(user)
    });
  } catch (error) {
    console.error('Error suspending user:', error);
    res.status(500).json({ success: false, message: 'Error suspending user' });
  }
});

// Delete user
router.delete('/users/:userId', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;

    const user = await User.findByIdAndDelete(userId);

    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    // Also delete related data
    if (user.user_type === 'service_provider') {
      const provider = await ServiceProvider.findOne({ user_id: userId });
      if (provider) {
        await Service.deleteMany({ provider_id: provider._id });
        await ServiceProvider.findByIdAndDelete(provider._id);
      }
    }

    res.json({
      success: true,
      message: 'User deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting user:', error);
    res.status(500).json({ success: false, message: 'Error deleting user' });
  }
});

// ==========================================
// SERVICE MANAGEMENT
// ==========================================

// Get all services
router.get('/services', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { category, status, search, page = 1, limit = 20 } = req.query;
    const filter = {};

    if (category) filter.category = category;
    if (status === 'approved') filter.is_active = true;
    if (status === 'pending') filter.is_active = false;
    if (search) {
      filter.$or = [
        { title: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } }
      ];
    }

    const services = await Service.find(filter)
      .populate('provider_id')
      .skip((page - 1) * limit)
      .limit(parseInt(limit))
      .sort({ created_at: -1 })
      .lean();

    const total = await Service.countDocuments(filter);

    // Get stats
    const stats = {
      total: await Service.countDocuments(),
      active: await Service.countDocuments({ is_active: true }),
      pending: await Service.countDocuments({ is_active: false }),
      inactive: 0
    };

    res.json({
      success: true,
      services: serializeDocuments(services),
      stats,
      total,
      page: parseInt(page),
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    console.error('Error fetching services:', error);
    res.status(500).json({ success: false, message: 'Error fetching services' });
  }
});

// Get service by ID
router.get('/services/:serviceId', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { serviceId } = req.params;
    const service = await Service.findById(serviceId)
      .populate('provider_id')
      .lean();

    if (!service) {
      return res.status(404).json({ success: false, message: 'Service not found' });
    }

    res.json({
      success: true,
      service: serializeDocument(service)
    });
  } catch (error) {
    console.error('Error fetching service:', error);
    res.status(500).json({ success: false, message: 'Error fetching service' });
  }
});

// Get pending services
router.get('/services/pending', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20 } = req.query;

    const services = await Service.find({ is_active: false })
      .populate('provider_id')
      .skip((page - 1) * limit)
      .limit(parseInt(limit))
      .sort({ created_at: -1 })
      .lean();

    const total = await Service.countDocuments({ is_active: false });

    res.json({
      success: true,
      services: serializeDocuments(services),
      total,
      page: parseInt(page),
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    console.error('Error fetching pending services:', error);
    res.status(500).json({ success: false, message: 'Error fetching pending services' });
  }
});

// Get service stats
router.get('/services/stats', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const stats = {
      total: await Service.countDocuments(),
      active: await Service.countDocuments({ is_active: true }),
      pending: await Service.countDocuments({ is_active: false }),
      byCategory: await Service.aggregate([
        { $group: { _id: '$category', count: { $sum: 1 } } }
      ])
    };

    res.json({ success: true, stats });
  } catch (error) {
    console.error('Error fetching service stats:', error);
    res.status(500).json({ success: false, message: 'Error fetching service stats' });
  }
});

// Approve service
router.post('/services/:serviceId/approve', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { serviceId } = req.params;

    const service = await Service.findByIdAndUpdate(
      serviceId,
      { is_active: true },
      { new: true }
    ).lean();

    if (!service) {
      return res.status(404).json({ success: false, message: 'Service not found' });
    }

    res.json({
      success: true,
      message: 'Service approved successfully',
      service: serializeDocument(service)
    });
  } catch (error) {
    console.error('Error approving service:', error);
    res.status(500).json({ success: false, message: 'Error approving service' });
  }
});

// Reject service
router.post('/services/:serviceId/reject', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { serviceId } = req.params;
    const { reason } = req.body;

    const service = await Service.findByIdAndUpdate(
      serviceId,
      { is_active: false, rejection_reason: reason },
      { new: true }
    ).lean();

    if (!service) {
      return res.status(404).json({ success: false, message: 'Service not found' });
    }

    res.json({
      success: true,
      message: 'Service rejected',
      service: serializeDocument(service)
    });
  } catch (error) {
    console.error('Error rejecting service:', error);
    res.status(500).json({ success: false, message: 'Error rejecting service' });
  }
});

// Delete service
router.delete('/services/:serviceId', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { serviceId } = req.params;

    const service = await Service.findByIdAndDelete(serviceId);

    if (!service) {
      return res.status(404).json({ success: false, message: 'Service not found' });
    }

    // Delete related bookings
    await Booking.deleteMany({ service_id: serviceId });

    res.json({
      success: true,
      message: 'Service deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting service:', error);
    res.status(500).json({ success: false, message: 'Error deleting service' });
  }
});

// ==========================================
// BOOKING MANAGEMENT
// ==========================================

// Get all bookings
router.get('/bookings', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { status, search, dateFrom, dateTo, page = 1, limit = 20 } = req.query;
    const filter = {};

    if (status) filter.status = status;
    if (dateFrom || dateTo) {
      filter.booking_date = {};
      if (dateFrom) filter.booking_date.$gte = new Date(dateFrom);
      if (dateTo) filter.booking_date.$lte = new Date(dateTo);
    }

    const bookings = await Booking.find(filter)
      .populate('user_id')
      .populate('service_id')
      .skip((page - 1) * limit)
      .limit(parseInt(limit))
      .sort({ created_at: -1 })
      .lean();

    const total = await Booking.countDocuments(filter);

    // Get stats
    const stats = {
      total: await Booking.countDocuments(),
      confirmed: await Booking.countDocuments({ status: 'confirmed' }),
      pending: await Booking.countDocuments({ status: 'pending' }),
      revenue: (await Payment.aggregate([
        { $match: { payment_status: 'completed' } },
        { $group: { _id: null, total: { $sum: '$amount' } } }
      ]))[0]?.total || 0
    };

    res.json({
      success: true,
      bookings: serializeDocuments(bookings),
      stats,
      total,
      page: parseInt(page),
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    console.error('Error fetching bookings:', error);
    res.status(500).json({ success: false, message: 'Error fetching bookings' });
  }
});

// Get booking by ID
router.get('/bookings/:bookingId', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { bookingId } = req.params;
    const booking = await Booking.findById(bookingId)
      .populate('user_id')
      .populate('service_id')
      .lean();

    if (!booking) {
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }

    res.json({
      success: true,
      booking: serializeDocument(booking)
    });
  } catch (error) {
    console.error('Error fetching booking:', error);
    res.status(500).json({ success: false, message: 'Error fetching booking' });
  }
});

// Get booking stats
router.get('/bookings/stats', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const stats = {
      total: await Booking.countDocuments(),
      confirmed: await Booking.countDocuments({ status: 'confirmed' }),
      pending: await Booking.countDocuments({ status: 'pending' }),
      completed: await Booking.countDocuments({ status: 'completed' }),
      cancelled: await Booking.countDocuments({ status: 'cancelled' })
    };

    res.json({ success: true, stats });
  } catch (error) {
    console.error('Error fetching booking stats:', error);
    res.status(500).json({ success: false, message: 'Error fetching booking stats' });
  }
});

// Cancel booking
router.post('/bookings/:bookingId/cancel', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { bookingId } = req.params;
    const { reason } = req.body;

    const booking = await Booking.findByIdAndUpdate(
      bookingId,
      { status: 'cancelled', cancellation_reason: reason },
      { new: true }
    ).lean();

    if (!booking) {
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }

    res.json({
      success: true,
      message: 'Booking cancelled successfully',
      booking: serializeDocument(booking)
    });
  } catch (error) {
    console.error('Error cancelling booking:', error);
    res.status(500).json({ success: false, message: 'Error cancelling booking' });
  }
});

// ==========================================
// PAYMENT MANAGEMENT
// ==========================================

// Get all payments
router.get('/payments', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { status, search, dateFrom, dateTo, page = 1, limit = 20 } = req.query;
    const filter = {};

    if (status) filter.payment_status = status;
    if (dateFrom || dateTo) {
      filter.created_at = {};
      if (dateFrom) filter.created_at.$gte = new Date(dateFrom);
      if (dateTo) filter.created_at.$lte = new Date(dateTo);
    }

    const payments = await Payment.find(filter)
      .populate('user_id')
      .populate('booking_id')
      .skip((page - 1) * limit)
      .limit(parseInt(limit))
      .sort({ created_at: -1 })
      .lean();

    const total = await Payment.countDocuments(filter);

    // Get stats
    const stats = {
      total: await Payment.countDocuments(),
      completed: (await Payment.aggregate([
        { $match: { payment_status: 'completed' } },
        { $group: { _id: null, total: { $sum: '$amount' } } }
      ]))[0]?.total || 0,
      pending: (await Payment.aggregate([
        { $match: { payment_status: 'pending' } },
        { $group: { _id: null, total: { $sum: '$amount' } } }
      ]))[0]?.total || 0,
      failed: await Payment.countDocuments({ payment_status: 'failed' })
    };

    res.json({
      success: true,
      payments: serializeDocuments(payments),
      stats,
      total,
      page: parseInt(page),
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    console.error('Error fetching payments:', error);
    res.status(500).json({ success: false, message: 'Error fetching payments' });
  }
});

// Get payment by ID
router.get('/payments/:paymentId', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const { paymentId } = req.params;
    const payment = await Payment.findById(paymentId)
      .populate('user_id')
      .populate('booking_id')
      .lean();

    if (!payment) {
      return res.status(404).json({ success: false, message: 'Payment not found' });
    }

    res.json({
      success: true,
      payment: serializeDocument(payment)
    });
  } catch (error) {
    console.error('Error fetching payment:', error);
    res.status(500).json({ success: false, message: 'Error fetching payment' });
  }
});

// Get payment stats
router.get('/payments/stats', authenticateJWT, isAdmin, async (req, res) => {
  try {
    const stats = {
      total: await Payment.countDocuments(),
      completed: await Payment.countDocuments({ payment_status: 'completed' }),
      pending: await Payment.countDocuments({ payment_status: 'pending' }),
      failed: await Payment.countDocuments({ payment_status: 'failed' }),
      totalRevenue: (await Payment.aggregate([
        { $match: { payment_status: 'completed' } },
        { $group: { _id: null, total: { $sum: '$amount' } } }
      ]))[0]?.total || 0
    };

    res.json({ success: true, stats });
  } catch (error) {
    console.error('Error fetching payment stats:', error);
    res.status(500).json({ success: false, message: 'Error fetching payment stats' });
  }
});

module.exports = router;